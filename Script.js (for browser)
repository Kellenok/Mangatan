// ==UserScript==
// @name         Automatic Content OCR (Local Overlay Manager - v6.2 Scrollbar Fix)
// @namespace    http://tampermonkey.net/
// @version      6.2
// @description  The definitive, feature-complete version. Fixes double scrollbar issue while ensuring overlays are visible. Includes configurable server URL and improved UI.
// @author       1Selxo
// @match        *://127.0.0.1/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @connect      127.0.0.1
// @connect      localhost
// @connect      fonts.googleapis.com
// @connect      fonts.gstatic.com
// @connect      *
// ==/UserScript==

(function() {
    'use strict';

    // --- Global State and Settings ---
    let settings = {
        ocrServerUrl: 'http://127.0.0.1:3000',
        sites: [{
            urlPattern: '127.0.0.1',
            imageContainerSelector: 'div.muiltr-masn8',
            overflowFixSelector: '.MuiBox-root.muiltr-13djdhf'
        }],
        debugMode: true,
        textOrientation: 'smart',
        fontSizePercent: 4,
    };
    let debugLog = [];
    const ocrCache = new WeakMap();
    const managedElements = new Map();
    let activeSiteConfig = null;

    // --- Logging Utility ---
    const logDebug = (message) => {
        if (!settings.debugMode) return;
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;
        console.log(`Local OCR: ${logEntry}`);
        debugLog.push(logEntry);
        document.dispatchEvent(new CustomEvent('ocr-log-update'));
    };

    // --- Persistence Module ---
    const PersistentCache = {
        CACHE_KEY: 'gemini_ocr_local_cache_v1', data: null,
        async load() { try { const d = await GM_getValue(this.CACHE_KEY); this.data = d ? new Map(Object.entries(JSON.parse(d))) : new Map(); logDebug(`Loaded ${this.data.size} items from cache.`); } catch (e) { logDebug(`Error loading cache: ${e.message}.`); this.data = new Map(); } },
        async save() { if (this.data) { try { await GM_setValue(this.CACHE_KEY, JSON.stringify(Object.fromEntries(this.data))); } catch (e) {} } },
        get(key) { return this.data?.get(key); },
        has(key) { return this.data?.has(key) ?? false; },
        async set(key, value) { this.data?.set(key, value); await this.save(); },
    };

    // --- CORE LOGIC (Passive Observer) ---
    function activateScanner() {
        logDebug("Activating passive scanner v6.2...");
        activeSiteConfig = settings.sites.find(site => window.location.href.includes(site.urlPattern));
        if (!activeSiteConfig) return logDebug(`No matching site config for URL: ${window.location.href}`);

        const pageObserver = new MutationObserver((mutations, observer) => {
            const container = document.querySelector(activeSiteConfig.imageContainerSelector);
            if (container) {
                logDebug(`Target container found: "${activeSiteConfig.imageContainerSelector}". Monitoring for images.`);
                observer.disconnect();
                monitorContainerForImages(container);
            }
        });
        pageObserver.observe(document.body, { childList: true, subtree: true });
    }

    function monitorContainerForImages(container) {
        const newImageObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) for (const node of mutation.addedNodes) {
                if (node.tagName === 'IMG') observeImageForSrcChange(node);
                else if (node.querySelectorAll) node.querySelectorAll('img').forEach(observeImageForSrcChange);
            }
        });
        newImageObserver.observe(container, { childList: true, subtree: true });
        container.querySelectorAll('img').forEach(observeImageForSrcChange);
    }

    function observeImageForSrcChange(img) {
        if (img.dataset.ocrListenerAttached) return;
        img.dataset.ocrListenerAttached = 'true';
        const processTheImage = (src) => {
            if (src && src.includes('/api/v1/manga/')) {
                logDebug(`Valid SRC detected: ...${src.slice(-40)}`);
                primeImageForOcr(img);
                return true;
            } return false;
        };
        if (processTheImage(img.src)) return;
        const attributeObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) if (mutation.attributeName === 'src') {
                if (processTheImage(img.src)) {
                    logDebug(`SRC changed, valid URL found. Disconnecting listener.`);
                    attributeObserver.disconnect();
                    break;
                }
            }
        });
        attributeObserver.observe(img, { attributes: true });
    }

    function primeImageForOcr(img) {
        if (img.dataset.ocrPrimed) return;
        img.dataset.ocrPrimed = 'true';
        const realSrc = img.src;
        if (PersistentCache.has(realSrc)) {
            logDebug(`Cache HIT for: ...${realSrc.slice(-20)}`);
            ocrCache.set(img, PersistentCache.get(realSrc));
            if (img.complete) displayOcrResults(img); else img.addEventListener('load', () => displayOcrResults(img), { once: true });
            return;
        }
        if (img.complete) processImage(img, realSrc); else img.addEventListener('load', () => processImage(img, realSrc), { once: true });
    }

    function processImage(img, sourceUrl) {
        if (ocrCache.has(img) && ocrCache.get(img) !== 'pending') return;
        logDebug(`Requesting OCR for ...${sourceUrl.slice(-40)}`);
        ocrCache.set(img, 'pending');
        GM_xmlhttpRequest({
            method: 'GET', url: `${settings.ocrServerUrl}/ocr?url=${encodeURIComponent(sourceUrl)}`, timeout: 30000,
            onload: (response) => {
                try {
                    if (response.status !== 200) throw new Error(`Server status ${response.status}`);
                    const parsedData = JSON.parse(response.responseText);
                    if (parsedData.error) throw new Error(`Server error: ${parsedData.error}`);
                    PersistentCache.set(sourceUrl, parsedData); ocrCache.set(img, parsedData);
                    logDebug(`OCR success for ...${sourceUrl.slice(-20)}`);
                    displayOcrResults(img);
                } catch (e) { logDebug(`OCR Error from server: ${e.message}`); ocrCache.delete(img); }
            },
            onerror: (err) => { logDebug(`Cannot connect to local OCR server: ${JSON.stringify(err)}`); ocrCache.delete(img); },
            ontimeout: () => { logDebug(`Request timed out for ...${sourceUrl.slice(-20)}`); ocrCache.delete(img); }
        });
    }

    // --- DISPLAY LOGIC (Managed Phantom Overlay) ---
    function displayOcrResults(targetImg) {
        const data = ocrCache.get(targetImg);
        if (!data || data === 'pending' || managedElements.has(targetImg)) return;

        const overlayContainer = document.createElement('div');
        overlayContainer.className = 'gemini-ocr-phantom-overlay';
        document.body.appendChild(overlayContainer);

        data.forEach((item) => {
            const ocrBox = document.createElement('div');
            ocrBox.className = 'gemini-ocr-text-box';
            ocrBox.textContent = item.text;

            const isVertical = item.tightBoundingBox.height > item.tightBoundingBox.width;
            if (settings.textOrientation === 'forceVertical' || (settings.textOrientation === 'smart' && isVertical)) {
                ocrBox.classList.add('gemini-ocr-text-vertical');
            }

            ocrBox.style.left = `${item.tightBoundingBox.x * 100}%`;
            ocrBox.style.top = `${item.tightBoundingBox.y * 100}%`;
            ocrBox.style.width = `${item.tightBoundingBox.width * 100}%`;
            ocrBox.style.height = `${item.tightBoundingBox.height * 100}%`;
            overlayContainer.appendChild(ocrBox);
        });

        managedElements.set(targetImg, { overlay: overlayContainer });
        logDebug(`Created and now managing overlay for image: ...${targetImg.src.slice(-20)}`);

        targetImg.addEventListener('mouseenter', () => { overlayContainer.style.visibility = 'visible'; overlayContainer.style.opacity = '1'; });
        overlayContainer.addEventListener('mouseleave', () => { overlayContainer.style.visibility = 'hidden'; overlayContainer.style.opacity = '0'; });

        overlayContainer.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('gemini-ocr-text-box')) {
                overlayContainer.classList.add('is-focused');
                e.target.classList.add('focused');
            }
        });
        overlayContainer.addEventListener('mouseout', (e) => {
            if (e.target.classList.contains('gemini-ocr-text-box')) {
                overlayContainer.classList.remove('is-focused');
                e.target.classList.remove('focused');
            }
        });
    }

    // --- Overlay Sync & Garbage Collection Loop ---
    function updateAllOverlays() {
        if (activeSiteConfig && activeSiteConfig.overflowFixSelector) {
            const problematicElement = document.querySelector(activeSiteConfig.overflowFixSelector);
            if (problematicElement && problematicElement.style.overflow !== 'visible') {
                problematicElement.style.overflow = 'visible';
                logDebug(`Applied overflow:visible to ${activeSiteConfig.overflowFixSelector}`);
            }
        }

        for (const [img, data] of managedElements.entries()) {
            if (!document.body.contains(img)) {
                data.overlay.remove();
                managedElements.delete(img);
                logDebug(`Garbage collected overlay for removed image: ...${img.src.slice(-20)}`);
                continue;
            }
            const rect = img.getBoundingClientRect();
            data.overlay.style.top = `${rect.top + window.scrollY}px`;
            data.overlay.style.left = `${rect.left + window.scrollX}px`;
            data.overlay.style.width = `${rect.width}px`;
            data.overlay.style.height = `${rect.height}px`;

            const ocrData = ocrCache.get(img);
            if (ocrData) {
                data.overlay.childNodes.forEach((ocrBox) => {
                    const userDefinedSize = rect.height * (settings.fontSizePercent / 100);
                    ocrBox.style.fontSize = `${Math.max(userDefinedSize, 8)}px`;
                });
            }
        }
        requestAnimationFrame(updateAllOverlays);
    }

    // --- UI SETUP ---
    async function createUI() {
        GM_addStyle(`
            /* --- FIX: PREVENT DOUBLE SCROLLBAR --- */
            html {
                overflow: hidden !important; /* Prevents the root element from showing a scrollbar */
            }
            body {
                 /* Let the body handle its own scrolling, which is the desired primary scrollbar */
                overflow-y: auto !important;
                overflow-x: hidden !important;
            }
            /* --- END FIX --- */

            #gemini-ocr-settings-button { position: fixed; bottom: 15px; right: 15px; z-index: 2147483646; background: #1F1F23; color: #EAEAEA; border: 1px solid #555; border-radius: 50%; width: 45px; height: 45px; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.4); user-select: none; }
            .gemini-ocr-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #1F1F23; border: 1px solid #00BFFF; border-radius: 15px; padding: 25px; z-index: 2147483647; color: #EAEAEA; font-family: 'Noto Sans JP', sans-serif; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); width: 600px; max-width: 90vw; }
            #gemini-ocr-debug-modal { width: 80vw; height: 80vh; flex-direction: column; }
            .gemini-ocr-modal.is-hidden { display: none !important; }
            .gemini-ocr-modal.is-visible { display: flex !important; flex-direction: column; }
            .gemini-ocr-modal h2, .gemini-ocr-modal h3 { margin-top: 0; color: #00BFFF; }
            .gemini-ocr-modal h3 { font-size: 1.1em; margin-bottom: -5px; margin-top: 20px; border-bottom: 1px solid #444; padding-bottom: 5px; }
            .gemini-ocr-settings-grid { display: grid; grid-template-columns: max-content 1fr; gap: 12px; align-items: center; }
            .gemini-ocr-settings-grid .full-width { grid-column: 1 / -1; }
            .gemini-ocr-modal-buttons { grid-column: 1 / -1; display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 15px; }
            .gemini-ocr-modal input, .gemini-ocr-modal textarea, .gemini-ocr-modal select, #gemini-ocr-debug-log { width: 100%; padding: 8px; box-sizing: border-box; font-family: monospace; background-color: #2a2a2e; border: 1px solid #555; border-radius: 5px; color: #EAEAEA; font-size: 14px; }
            .gemini-ocr-modal input[type="number"] { width: 80px; }
            #gemini-ocr-debug-log { flex-grow: 1; resize: none; }
            .gemini-ocr-modal textarea { height: 120px; }
            .gemini-ocr-modal button { padding: 10px 18px; background-color: #00BFFF; border: none; border-radius: 5px; color: #1A1A1D; cursor: pointer; font-weight: bold; }
            .gemini-ocr-phantom-overlay { position: absolute; z-index: 9999; visibility: hidden; opacity: 0; pointer-events: auto; transition: opacity 0.2s ease-in-out; }
            .gemini-ocr-text-box { font-family: 'Noto Sans JP', sans-serif; position: absolute; background: rgba(10, 25, 40, 0.6); border: 2px solid rgba(0, 191, 255, 0.7); color: white; text-shadow: 1px 1px 2px #000, -1px -1px 2px #000, 1px -1px 2px #000, -1px 1px 2px #000; backdrop-filter: blur(1.5px); line-height: 1.25; display: flex; align-items: center; justify-content: center; text-align: center; border-radius: 3px; box-sizing: border-box; user-select: text; cursor: text; pointer-events: auto; transition: opacity 0.2s, transform 0.2s, z-index 0s 0.2s; overflow: visible; }
            .gemini-ocr-text-vertical { writing-mode: vertical-rl !important; text-orientation: upright !important; letter-spacing: 0.1em; }
            .gemini-ocr-phantom-overlay.is-focused .gemini-ocr-text-box { opacity: 0.5; }
            .gemini-ocr-phantom-overlay.is-focused .gemini-ocr-text-box.focused { opacity: 1; z-index: 10; transform: scale(1.05); }
            #gemini-ocr-server-status { grid-column: 1 / -1; padding: 10px; border: 1px solid #555; border-radius: 5px; text-align: center; font-weight: bold; transition: all 0.3s ease; cursor: pointer; }
            #gemini-ocr-server-status.status-ok { background-color: #27ae60; color: white; border-color: #2ecc71; }
            #gemini-ocr-server-status.status-error { background-color: #c0392b; color: white; border-color: #e74c3c; }
            #gemini-ocr-server-status.status-checking { background-color: #3498db; color: white; border-color: #5dade2; }
            @media (max-width: 600px) {
                .gemini-ocr-modal { padding: 15px; width: 95vw; max-height: 90vh; overflow-y: auto; }
                .gemini-ocr-settings-grid { display: block; }
                .gemini-ocr-settings-grid > label { display: block; margin-top: 15px; font-weight: bold; }
                .gemini-ocr-modal-buttons { justify-content: space-between; }
            }
        `);

        const settingsButton = document.createElement('button'); settingsButton.id = 'gemini-ocr-settings-button'; settingsButton.innerHTML = '⚙️'; document.body.appendChild(settingsButton);
        const modal = document.createElement('div'); modal.id = 'gemini-ocr-settings-modal'; modal.classList.add('gemini-ocr-modal', 'is-hidden');
        modal.innerHTML = `
            <h2 class="full-width">Local OCR Settings (v6.2)</h2>
            <div class="gemini-ocr-settings-grid">
                <h3 class="full-width">Connection</h3>
                <label class="full-width" for="gemini-ocr-server-url">OCR Server URL:</label>
                <input type="text" id="gemini-ocr-server-url" class="full-width">
                <div id="gemini-ocr-server-status" title="Click to check status">Click to check server status</div>

                <h3 class="full-width">Text Display</h3>
                <label for="ocr-text-orientation">Text Orientation:</label> <select id="ocr-text-orientation"> <option value="smart">Smart Detection</option> <option value="forceHorizontal">Force Horizontal</option> <option value="forceVertical">Force Vertical</option> </select>
                <label for="ocr-font-size">Font Size (% of image height):</label> <input type="number" id="ocr-font-size" min="1" max="50" step="0.5">

                <h3 class="full-width">Advanced</h3>
                <div class="full-width"> <label><input type="checkbox" id="gemini-ocr-debug-mode"> Debug Mode</label> </div>
                <div class="full-width"> <label for="gemini-ocr-sites-config">Site Configurations (URL_Pattern, Image_Container, Overflow_Fix):</label> <textarea id="gemini-ocr-sites-config" rows="4"></textarea> </div>
                <div class="gemini-ocr-modal-buttons full-width"> <button id="gemini-ocr-debug-btn" style="background-color: #777; margin-right: auto;">Debug Logs</button> <button id="gemini-ocr-close-btn" style="background-color: #555;">Close</button> <button id="gemini-ocr-save-btn">Save and Reload</button> </div>
            </div>`;
        document.body.appendChild(modal);

        const debugModal = document.createElement('div'); debugModal.id = 'gemini-ocr-debug-modal'; debugModal.classList.add('gemini-ocr-modal', 'is-hidden');
        debugModal.innerHTML = `<h2>Debug Log</h2><textarea id="gemini-ocr-debug-log" readonly></textarea><button id="gemini-ocr-close-debug-btn" style="background-color: #555;">Close</button>`;
        document.body.appendChild(debugModal);

        const loadedSettings = await GM_getValue('gemini_ocr_observer_settings_v6.2');
        if (loadedSettings) { settings = { ...settings, ...JSON.parse(loadedSettings) }; }

        document.getElementById('gemini-ocr-server-url').value = settings.ocrServerUrl;
        document.getElementById('gemini-ocr-debug-mode').checked = settings.debugMode;
        document.getElementById('ocr-text-orientation').value = settings.textOrientation;
        document.getElementById('ocr-font-size').value = settings.fontSizePercent;
        document.getElementById('gemini-ocr-sites-config').value = settings.sites.map(s => `${s.urlPattern}, ${s.imageContainerSelector}, ${s.overflowFixSelector}`).join('\n');

        settingsButton.addEventListener('click', () => modal.classList.toggle('is-hidden'));
        document.getElementById('gemini-ocr-close-btn').addEventListener('click', () => modal.classList.add('is-hidden'));
        document.getElementById('gemini-ocr-server-status').addEventListener('click', checkServerStatus);
        const debugTextarea = document.getElementById('gemini-ocr-debug-log');
        document.getElementById('gemini-ocr-debug-btn').addEventListener('click', () => { debugModal.classList.remove('is-hidden'); debugTextarea.value = debugLog.join('\n'); debugTextarea.scrollTop = debugTextarea.scrollHeight; });
        document.getElementById('gemini-ocr-close-debug-btn').addEventListener('click', () => { debugModal.classList.add('is-hidden'); });
        document.addEventListener('ocr-log-update', () => { if (!debugModal.classList.contains('is-hidden')) { debugTextarea.value = debugLog.join('\n'); debugTextarea.scrollTop = debugTextarea.scrollHeight; } });
        document.getElementById('gemini-ocr-save-btn').addEventListener('click', async () => {
            const newSettings = {
                ocrServerUrl: document.getElementById('gemini-ocr-server-url').value.trim(),
                debugMode: document.getElementById('gemini-ocr-debug-mode').checked,
                textOrientation: document.getElementById('ocr-text-orientation').value,
                fontSizePercent: parseFloat(document.getElementById('ocr-font-size').value) || 4,
                sites: document.getElementById('gemini-ocr-sites-config').value.split('\n').filter(line => line.includes(',')).map(line => {
                    const parts = line.split(',').map(s => s.trim());
                    return { urlPattern: parts[0], imageContainerSelector: parts[1], overflowFixSelector: parts[2] };
                })
            };
            await GM_setValue('gemini_ocr_observer_settings_v6.2', JSON.stringify(newSettings));
            alert('Settings Saved. The page will now reload.'); window.location.reload();
        });
    }

    function checkServerStatus() {
        const statusDiv = document.getElementById('gemini-ocr-server-status');
        const serverUrl = document.getElementById('gemini-ocr-server-url').value.trim();
        if (!statusDiv || !serverUrl) return;

        statusDiv.className = 'status-checking'; statusDiv.textContent = 'Checking...';
        GM_xmlhttpRequest({
            method: 'GET', url: serverUrl, timeout: 5000,
            onload: (res) => {
                try {
                    const data = JSON.parse(res.responseText);
                    if (data.status === 'running') {
                        statusDiv.className = 'status-ok';
                        statusDiv.textContent = `Connected (${data.items_in_cache} cached)`;
                    } else { throw new Error('Invalid response'); }
                } catch (e) { statusDiv.className = 'status-error'; statusDiv.textContent = 'Unresponsive Server'; }
            },
            onerror: () => { statusDiv.className = 'status-error'; statusDiv.textContent = 'Connection Failed'; },
            ontimeout: () => { statusDiv.className = 'status-error'; statusDiv.textContent = 'Connection Timed Out'; }
        });
    }

    // --- SCRIPT INITIALIZATION ---
    async function init() {
        await PersistentCache.load();
        await createUI();
        activateScanner();
        requestAnimationFrame(updateAllOverlays);
    }

    init().catch(console.error);
})();
